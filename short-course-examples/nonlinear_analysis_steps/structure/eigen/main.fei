

model name "shell_structure" ;

Elastic = 2e8*N/m^2; 
nu    = 0.1;        
rho   = 1800*kg/m^3;     

add material # 1 type linear_elastic_isotropic_3d
  mass_density = rho
  elastic_modulus = Elastic
  poisson_ratio = nu;
 
add material # 2 type linear_elastic_isotropic_3d
  mass_density = rho
  elastic_modulus = Elastic
  poisson_ratio = nu;

add material # 3 type linear_elastic_isotropic_3d
  mass_density = rho
  elastic_modulus = Elastic
  poisson_ratio = nu;

shell_Elastic = 2.48e11*N/m^2; 
shell_v    = 0.1;        
shell_rho   = 3000*kg/m^3;    

add material # 4 type linear_elastic_isotropic_3d
  mass_density = shell_rho
  elastic_modulus = shell_Elastic
  poisson_ratio = shell_v;

add material # 5 type linear_elastic_isotropic_3d
  mass_density = rho
  elastic_modulus = Elastic
  poisson_ratio = nu;
// bonded Contact penalty_stiffness. 
Kn = 1e11 * kg /s^2 ; 

include "node.fei";
include "element.fei";
include "load.fei";


new loading stage "eigen";
// simulate using eigen algorithm number_of_modes = <.>;
simulate using eigen algorithm 
  number_of_modes = 6;



// // check model;
// new loading stage "Self_weight";
// add acceleration field # 1 
//   ax =  0*g
//   ay =  0*g
//   az =  -g ;
// add load # 1 to all elements type self_weight use acceleration field # 1;

// // define algorithm With_no_convergence_check ;
// define convergence test Relative_Norm_Displacement_Increment 
//   tolerance =  1E-3
//   minimum_absolute_tolerance = 0.05
//   maximum_iterations = 20 ;
// define algorithm Newton;
// if(IS_PARALLEL==0)
// {define solver UMFPack;}
// else
// {define solver parallel;}
// define load factor increment 0.1;
// simulate 10 steps using static algorithm;








// new loading stage "motion";

// add wave field # 1 with
//   acceleration_filename = "scaled_NORTHR_x_A.txt"
//   unit_of_acceleration = 1 * m/s^2
//   displacement_filename = "scaled_NORTHR_x_D.txt"
//   unit_of_displacement = 1 * m
//   add_compensation_time = 0.5 * s
//   acceleration_depth = 0 * m
//   monitoring_location = within_soil_layer
//   soil_profile_filename = "soil_profile.txt"
//   unit_of_Vs = 1 * m/s
//   unit_of_rho = 1 * kg/m^3
//   unit_of_damping = absolute
//   unit_of_thickness = 1*m 
//   ;
  
// add wave field # 2 with
//   acceleration_filename = "scaled_NORTHR_y_A.txt"
//   unit_of_acceleration = 1 * m/s^2
//   displacement_filename = "scaled_NORTHR_y_D.txt"
//   unit_of_displacement = 1 * m
//   add_compensation_time = 0.5 * s
//   acceleration_depth = 0 * m
//   monitoring_location = within_soil_layer
//   soil_profile_filename = "soil_profile.txt"
//   unit_of_Vs = 1 * m/s
//   unit_of_rho = 1 * kg/m^3
//   unit_of_damping = absolute
//   unit_of_thickness = 1*m 
//   ;

// add wave field # 3 with
//   acceleration_filename = "scaled_NORTHR_z_A.txt"
//   unit_of_acceleration = 1 * m/s^2
//   displacement_filename = "scaled_NORTHR_z_D.txt"
//   unit_of_displacement = 1 * m
//   add_compensation_time = 0.5 * s
//   acceleration_depth = 0 * m
//   monitoring_location = within_soil_layer
//   soil_profile_filename = "soil_profile_Vp.txt"
//   unit_of_Vs = 1 * m/s
//   unit_of_rho = 1 * kg/m^3
//   unit_of_damping = absolute
//   unit_of_thickness = 1*m 
//   ;
// enable acceleration output; 
// //add load # 2 type domain reduction method 
//   //  hdf5_file = "DRM_Input.hdf5" ; 
// add load # 2 type DRM from wave field 
//     # 1 in direction ux 
//     # 2 in direction uy
//     # 3 in direction uz
//     soil_surface at z = 10 * m 
//     hdf5_file = "DRMinput.hdf5" ; 
// // add load # 2 type DRM from wave field # 1 
// //     in direction ux 
// //     soil_surface at z = 10 * m 
// //     hdf5_file = "DRMinput.hdf5" ; 
// // define algorithm With_no_convergence_check ;
// define convergence test Relative_Norm_Displacement_Increment 
//   tolerance =  1E-3
//   minimum_absolute_tolerance = 0.05
//   maximum_iterations = 20 ;

// // define convergence test Norm_Unbalance tolerance = 1E-2 maximum_iterations = 20 verbose_level = 1; 
// define algorithm Newton; 
// if(IS_PARALLEL==0)
// {define solver UMFPack;}
// else
// {define solver parallel;}
// // define dynamic integrator Newmark with 
//    // gamma = 0.5050 
//    // beta = 0.2525;

// define dynamic integrator Newmark with 
//    gamma = 0.50
//    beta = 0.25;
// simulate 300 steps using transient algorithm 
//     time_step = 0.01*s ;

bye;











